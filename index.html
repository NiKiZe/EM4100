<!DOCTYPE html>
<html itemscope="" itemtype="http://schema.org/WebPage" lang="en-US">
<head>
<head><meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EM4100 125KHz ID formattings</title>
<style>
body, input {
  font-family: Consolas, monospace;
}

.em4100 {
  width: 460px; margin-left: auto; margin-right: auto;
}
.em4100 td {
  white-space: nowrap;
  text-align: center;
  font-family: Consolas, monospace;
  min-width: 30px;
}

.em4100 td.h {
  background-color: #ff6666;
}
.em4100 td.v {
  background-color: #ffff66;
}
.em4100 td.data {
  background-color: #66ffff;
}
.em4100 td.parity {
  background-color: #ffcc99;
}

</style>
</head>
<body>
Protocol explanation from <a href="https://www.priority1design.com.au/em4100_protocol.html">priority1design.com.au</a> visualized.
<table class="em4100" border="0" cellpadding="3" cellspacing="0">
        <tbody>
          <tr>
            <td class="h">1</td>
            <td class="h">1</td>
            <td class="h">1</td>
            <td class="h">1</td>
            <td class="h">1</td>
            <td class="h">1</td>
            <td class="h">1</td>
            <td class="h">1</td>
            <td class="h">1</td>
            <td>9 header bits</td>
          </tr>
          <tr>
            <td colspan="4" rowspan="2">8 bit ver. no/<br/>customer ID</td>
            <td class="v" id="emd00">D00</td>
            <td class="v" id="emd01">D01</td>
            <td class="v" id="emd02">D02</td>
            <td class="v" id="emd03">D03</td>
            <td class="parity" id="emp0">P0</td>
            <td id="emx0"></td>
          </tr>
          <tr>
            <td class="v" id="emd04">D04</td>
            <td class="v" id="emd05">D05</td>
            <td class="v" id="emd06">D06</td>
            <td class="v" id="emd07">D07</td>
            <td class="parity" id="emp1">P1</td>
            <td id="emx1"></td>
          </tr>
          <tr>
            <td colspan="4" rowspan="8" style="vertical-align: top;">32 Data Bits</td>
            <td class="data" id="emd08">D08</td>
            <td class="data" id="emd09">D09</td>
            <td class="data" id="emd10">D10</td>
            <td class="data" id="emd11">D11</td>
            <td class="parity" id="emp2">P2</td>
            <td id="emx2"></td>
          </tr>
          <tr>
            <td class="data" id="emd12">D12</td>
            <td class="data" id="emd13">D13</td>
            <td class="data" id="emd14">D14</td>
            <td class="data" id="emd15">D15</td>
            <td class="parity" id="emp3">P3</td>
            <td id="emx3"></td>
          </tr>
          <tr>
            <td class="data" id="emd16">D16</td>
            <td class="data" id="emd17">D17</td>
            <td class="data" id="emd18">D18</td>
            <td class="data" id="emd19">D19</td>
            <td class="parity" id="emp4">P4</td>
            <td id="emx4"></td>
          </tr>
          <tr>
            <td class="data" id="emd20">D20</td>
            <td class="data" id="emd21">D21</td>
            <td class="data" id="emd22">D22</td>
            <td class="data" id="emd23">D23</td>
            <td class="parity" id="emp5">P5</td>
            <td id="emx5"></td>
          </tr>
          <tr>
            <td class="data" id="emd24">D24</td>
            <td class="data" id="emd25">D25</td>
            <td class="data" id="emd26">D26</td>
            <td class="data" id="emd27">D27</td>
            <td class="parity" id="emp6">P6</td>
            <td id="emx6"></td>
          </tr>
          <tr>
            <td class="data" id="emd28">D28</td>
            <td class="data" id="emd29">D29</td>
            <td class="data" id="emd30">D30</td>
            <td class="data" id="emd31">D31</td>
            <td class="parity" id="emp7">P7</td>
            <td id="emx7"></td>
          </tr>
          <tr>
            <td class="data" id="emd32">D32</td>
            <td class="data" id="emd33">D33</td>
            <td class="data" id="emd34">D34</td>
            <td class="data" id="emd35">D35</td>
            <td class="parity" id="emp8">P8</td>
            <td id="emx8"></td>
          </tr>
          <tr>
            <td class="data" id="emd36">D36</td>
            <td class="data" id="emd37">D37</td>
            <td class="data" id="emd38">D38</td>
            <td class="data" id="emd39">D39</td>
            <td class="parity" id="emp9">P9</td>
            <td id="emx9"></td>
          </tr>
          <tr>
            <td colspan="4">Col. parity</td>
            <td class="parity" id="empc0">PC0</td>
            <td class="parity" id="empc1">PC1</td>
            <td class="parity" id="empc2">PC2</td>
            <td class="parity" id="empc3">PC3</td>
            <td class="h">S0</td>
            <td>1 stop bit (0)</td>
          </tr>
        </tbody>
      </table>

<form>
  <fieldset>
    <legend>Format of value to convert</legend>
    <input type="radio" id="ch_hex" name="infmt" value="hex" />
    <label for="ch_hex">Hex</label>

    <input type="radio" id="ch_dec" name="infmt" value="dec" checked />
    <label for="ch_dec">Decimal</label>

    <input type="radio" id="ch_bewator" name="infmt" value="bewator" />
    <label for="ch_bewator">Bewator</label>
  </fieldset>
</form>
<input type="text" value="4324451201" id="taginput">
<div id="tagOut"></div>

<h4>Below you can input multiple values, one per line:</h4>
<textarea id="tagmulti" cols="60" rows="10"></textarea>

<h3>Different EM4100 number formattings as best as I have been able to reverse them</h3>
<table border="1" cellspacing="0" cellpadding="3">
  <tr>
    <th scope="col">format</th>
    <th scope="col">explanation</th>
  </tr>
  <tr>
    <th scope="row">HEX</th>
    <td>1 Byte version/customer id and 4 bytes data</td>
  </tr>
  <tr>
    <th scope="row">eAV - EM Full, Raw Dec</th>
    <td>HEX converted to full decimal number</td>
  </tr>
  <tr>
    <th scope="row">Dec 10</th>
    <td>4 ID bytes converted to decimal and zero padded</td>
  </tr>
  <tr>
    <th scope="row">Dec 8</th>
    <td>Last 3 ID bytes, split 1,2 and padded to 3,5</td>
  </tr>
  <tr>
    <th scope="row">eBe - EM Bewator 8</th>
    <td>Same as Dec 10, cut down to 8</td>
  </tr>
  <tr>
    <th scope="row">Bewator</th>
    <td>Same as Dec 10, prefixed with first byte</td>
  </tr>
  <tr>
    <th scope="row">eA - EM Aptus</th>
    <td>Full RAW Dec, cut and padded to 9 diggits</td>
  </tr>
  <tr>
    <th scope="row">eR - EM RCO</th>
    <td>4 ID bytes, split into 2 bytes each, padded to 5 diggits, combined and last 9 diggits used</td>
  </tr>
  <tr>
    <th scope="row">eS - EM Solid</th>
    <td>4 ID bytes, reversing all bits in each byte</td>
  </tr>
  <tr>
    <th scope="row">Axema</th>
    <td>Raw Dec, Often same as Aptus prefixed by a 4</td>
  </tr>

</table>

<script>
const zeroPad = (num, places) => String(num).padStart(places, '0')

function setEmBitDisplay(value) {
  if (value.length != 10) throw new Error("EM data must be 10 hex chars '" + value + "'");
  // TODO verify valid hex
  let i_r = 0;
  let p_c = [0, 0, 0, 0]
  for (let l = 0; l < value.length; l++) {
    document.getElementById("emx" + i_r).innerText=value[l];
    let bits = zeroPad(parseInt(value[l], 16).toString(2), 4)
    let pb = 0;
    for (let ib = 0; ib < 4; ib++) {
      let i = i_r * 4 + ib;
      let e = document.getElementById("emd" + zeroPad(i, 2));
      e.title="Data " + zeroPad(i, 2);
      let bdata = parseInt(bits[ib]);
      e.innerText=bdata;
      pb = pb ^ bdata;
      p_c[ib] = p_c[ib] ^ bdata;
    }
    let e = document.getElementById("emp" + i_r);
    e.title="Parity Row " + i_r;
    e.innerText=pb;
    
    i_r++;
  }
  for (let ib = 0; ib < 4; ib++) {
    let e = document.getElementById("empc" + ib);
    e.title="Parity Column " + ib;
    e.innerText=p_c[ib];
  }
}

function revbits(v) {
  // swap odd and even bits
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1);
  // swap consecutive pairs
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2);
  // swap nibbles ... 
  v = ((v >> 4) & 0x0F0F0F0F) | ((v & 0x0F0F0F0F) << 4);
  // swap bytes
  //v = ((v >> 8) & 0x00FF00FF) | ((v & 0x00FF00FF) << 8);
  // swap 2-byte long pairs
  //v = ( v >> 16             ) | ( v               << 16);
  return v >>> 0;
}

// convert input value 
function formatTags(value) {
  value = parseInt(value);
  let fh10 = zeroPad(value.toString(16), 10);
  var res = "Hex: 0x" + zeroPad(fh10.toUpperCase(), 10) +
            "\neAV RAW Dec: " + zeroPad(value, 14);
  if (fh10.length > 10) {
    return res + " can not be more than 10 nibbles long";
  }
  setEmBitDisplay(fh10);
  let h1 = parseInt(fh10.substring(0, 2), 16);
  let h8 = parseInt(fh10.substring(2), 16);
  let h24 = parseInt(fh10.substring(2, 6), 16);
  let hl4 = parseInt(fh10.substring(6), 16);
  let fd10 = zeroPad(h8, 10);
  let fd8 = zeroPad(parseInt(fh10.substring(4, 6), 16), 3) + zeroPad(hl4, 5);
  let rco = zeroPad(h24, 4) + zeroPad(hl4, 5);
  let apt = zeroPad(value.toString().substring(value.toString().length - 9), 9);
  res += "\nDec10: " + fd10 +
         "\nDec8: " + fd8 +
         "\neBe Bewator8: " + fd10.substring(2) +
         "\nBewator: 000 " + zeroPad(h1, 3) + " " + fd10.substring(0, 2) + " " + fd10.substring(2) +
         "\neA Aptus: " + apt +
         "\neR RCO: " + rco.substring(rco.length - 9) + 
         "\neS Solid: " + revbits(h8) +
         "\nAxema: " + value +
         "\n";
  return res;
}

function fmttovalue(value, fmt) {
  console.log(fmt, value);
  if (fmt === "hex") {
    return parseInt(value, 16);
  }
  if (fmt === "bewator") {
    // get 10 diggits, pad 8 diggits value with frequent value TODO make configurable
    if (value.length <= 8) value = "3" + zeroPad(value, 8);
    // prepend frequent first byte (if missing) TODO make configurable
    var h1 = 1;
    var fd10 = value
    if (value.length > 10) {
      fd10 = value.substring(value.length - 10);
      h1 = parseInt(value.substring(0, value.length - 10));
    }
    // value is 4 bytes id
    var h8 = zeroPad(parseInt(fd10).toString(16), 8);
    return parseInt(h1.toString(16) + h8, 16);
  }

  return parseInt(value);
}

const form = document.querySelector("form");
function getinfmt() {
  for (const entry of new FormData(form)) {
    return entry[1];
  }
  return "";
}
const taginp = document.getElementById("taginput");
const tagout = document.getElementById("tagOut");
function updateTag(e) {
  const v = fmttovalue(taginp.value, getinfmt())
  updateMulti();
  tagout.innerHTML = formatTags(v).replaceAll("\n", "<br/>\n");
}
for (const r of form.infmt) {
  r.addEventListener('change', updateTag);
}
taginp.addEventListener("input", updateTag);

const tagmulti = document.getElementById("tagmulti");
function updateMulti(e) {
  const infmt = getinfmt();
  // TODO maybe consider selectionEnd
  let p = tagmulti.value.substring(0, tagmulti.selectionStart).split('\n');
  // line is the number of lines
  let posline = p.length;
  // col is the length of the last line
  let poscol = p[p.length-1].length;

  let restorePos = -1;
  let res = "";
  for (const line of tagmulti.value.split('\n')) {
    if (restorePos === -1 && res.split('\n').length >= posline) {
      restorePos = res.length + poscol;
    }

    const val = line.trim().split('\t')[0];
    if (val.length == 0 || parseInt(val) == NaN) {
      res += val + '\n';
      continue;
    }
    const fmtd = formatTags(fmttovalue(val, infmt)).replaceAll('\n', '\t').trim();
    res += val + '\t' + fmtd + '\n';
    console.log(val, fmtd);
  }
  if (tagmulti.value != res) {
    tagmulti.value = res;
    if (restorePos != -1) {
      tagmulti.selectionStart = restorePos;
      tagmulti.selectionEnd = restorePos;
    }
  }
}
tagmulti.addEventListener("input", updateMulti);

function testcase(data, d10, d8, bewator, rco, solid, apt) {
  let f = formatTags("0x" + data);
  console.assert(f.includes("Hex: 0x" + data.toUpperCase() + "\n"));
  console.assert(f.includes("Dec10: " + d10 + "\n"));
  console.assert(f.includes("Dec8: " + d8 + "\n"));
  console.assert(f.replaceAll(" ", "").includes("Bewator:" + bewator.replaceAll(" ", "") + "\n"), "bewator " + bewator + " vs " + f);
  console.assert(f.includes("RCO: " + rco + "\n"), "rco " + rco + " vs " + f);
  console.assert(f.includes("Solid: " + solid + "\n"), "solid " + solid + " hex: " + parseInt(solid).toString(16) + " vs " + f);
  console.assert(f.includes("Aptus: " + apt + "\n"), "apt " + apt + " vs " + f);
}
testcase("0000000001", "0000000001", "00000001", "000 000 0000000001", "000000001", "128", "000000001");
testcase("0000000002", "0000000002", "00000002", "000 000 0000000002", "000000002", "64", "000000002");
testcase("0000000003", "0000000003", "00000003", "000 000 0000000003", "000000003", "192", "000000003");
testcase("0000000004", "0000000004", "00000004", "000 000 0000000004", "000000004", "32", "000000004");
testcase("0000000005", "0000000005", "00000005", "000 000 0000000005", "000000005", "160", "000000005");
testcase("0000000006", "0000000006", "00000006", "000 000 0000000006", "000000006", "96", "000000006");
testcase("0000000007", "0000000007", "00000007", "000 000 0000000007", "000000007", "224", "000000007");
testcase("0000000008", "0000000008", "00000008", "000 000 0000000008", "000000008", "16", "000000008");
testcase("00000000ff", "0000000255", "00000255", "000 000 0000000255", "000000255", "255", "000000255");
testcase("0000000100", "0000000256", "00000256", "000 000 0000000256", "000000256", "32768", "000000256");
testcase("0000000F00", "0000003840", "00003840", "000 000 0000003840", "000003840", "61440", "000003840");
testcase("000000F000", "0000061440", "00061440", "000 000 0000061440", "000061440", "3840", "000061440");
testcase("00000F0000", "0000983040", "01500000", "000 000 0000983040", "001500000", "15728640", "000983040");

testcase("0101c1e381", "0029483905", "19358241", "000 001 0029483905", "044958241", "2156119937", "324451201");
testcase("0017000002", "0385875970", "00000002", "000 000 0385875970", "588800002", "3892314176", "385875970");
testcase("0117000002", "0385875970", "00000002", "000 001 0385875970", "588800002", "3892314176", "680843266");
testcase("1fffffffff", "4294967295", "25565535", "000 031 4294967295", "553565535", "4294967295", "438953471");
testcase("5fffffffff", "4294967295", "25565535", "000 095 4294967295", "553565535", "4294967295", "316860415");
testcase("7F00000002", "0000000002", "00000002", "000 127 0000000002", "000000002", "64", "460846594");
testcase("7fffffffff", "4294967295", "25565535", "000 127 4294967295", "553565535", "4294967295", "755813887");
testcase("ffffffffff", "4294967295", "25565535", "000 255 4294967295", "553565535", "4294967295", "511627775");

updateTag();
</script>

&copy; Christian I. Nilsson 2025
</body>
</html>
